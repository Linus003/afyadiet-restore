{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///var/www/html/afyadiet/lib/session.ts"],"sourcesContent":["import { cookies } from \"next/headers\"\nimport { jwtVerify, SignJWT } from \"jose\"\n\nconst JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET || \"your-secret-key-change-in-production\")\n\nexport interface SessionPayload {\n  userId: string\n  email: string\n  role: \"client\" | \"nutritionist\" | \"admin\";\n}\n\nexport async function createSession(payload: SessionPayload): Promise<string> {\n  // ðŸ’¡ FIX: Spread payload into a new object to satisfy Type 'JWTPayload' requirements\n  const token = await new SignJWT({ ...payload })\n    .setProtectedHeader({ alg: \"HS256\" })\n    .setExpirationTime(\"7d\")\n    .sign(JWT_SECRET)\n\n  return token\n}\n\nexport async function verifySession(token: string): Promise<SessionPayload | null> {\n  try {\n    const verified = await jwtVerify(token, JWT_SECRET)\n    return verified.payload as unknown as SessionPayload\n  } catch (err) {\n    return null\n  }\n}\n\nexport async function setSessionCookie(token: string) {\n  const cookieStore = await cookies()\n  cookieStore.set(\"session\", token, {\n    httpOnly: true,\n    secure: true,   // Note: This requires HTTPS. If on localhost/http, login might fail.\n    sameSite: \"lax\",\n    maxAge: 7 * 24 * 60 * 60, // 7 days\n    path: \"/\",\n  })\n}\n\nexport async function getSessionFromCookie(): Promise<SessionPayload | null> {\n  try {\n    const cookieStore = await cookies()\n    const token = cookieStore.get(\"session\")?.value\n\n    if (!token) return null\n\n    return await verifySession(token)\n  } catch (err) {\n    return null\n  }\n}\n\nexport async function clearSessionCookie() {\n  const cookieStore = await cookies()\n  cookieStore.delete(\"session\")\n}"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AAAA;;;AAEA,MAAM,aAAa,IAAI,cAAc,MAAM,CAAC,QAAQ,GAAG,CAAC,UAAU,IAAI;AAQ/D,eAAe,cAAc,OAAuB;IACzD,qFAAqF;IACrF,MAAM,QAAQ,MAAM,IAAI,kKAAO,CAAC;QAAE,GAAG,OAAO;IAAC,GAC1C,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,iBAAiB,CAAC,MAClB,IAAI,CAAC;IAER,OAAO;AACT;AAEO,eAAe,cAAc,KAAa;IAC/C,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,sKAAS,EAAC,OAAO;QACxC,OAAO,SAAS,OAAO;IACzB,EAAE,OAAO,KAAK;QACZ,OAAO;IACT;AACF;AAEO,eAAe,iBAAiB,KAAa;IAClD,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,YAAY,GAAG,CAAC,WAAW,OAAO;QAChC,UAAU;QACV,QAAQ;QACR,UAAU;QACV,QAAQ,IAAI,KAAK,KAAK;QACtB,MAAM;IACR;AACF;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,4IAAO;QACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,YAAY;QAE1C,IAAI,CAAC,OAAO,OAAO;QAEnB,OAAO,MAAM,cAAc;IAC7B,EAAE,OAAO,KAAK;QACZ,OAAO;IACT;AACF;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,YAAY,MAAM,CAAC;AACrB"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///var/www/html/afyadiet/lib/db.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const db =\n  globalForPrisma.prisma ||\n  new PrismaClient({\n    log: ['query'],\n  });\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = db;\n\n// --- THE COMPATIBILITY LAYER ---\n\nexport function getSql() {\n  return async (query: string, params: any[] = []) => {\n    // 1. Convert Postgres syntax ($1, $2, etc) to MySQL syntax (?)\n    let mysqlQuery = query.replace(/\\$\\d+/g, '?');\n\n    // 2. Convert Postgres 'ILIKE' (Case Insensitive) to MySQL 'LIKE' (Default is case insensitive)\n    mysqlQuery = mysqlQuery.replace(/ILIKE/gi, 'LIKE');\n\n    // 3. Remove \"RETURNING *\" statements\n    // MySQL crashes if you try to use RETURNING, so we strip it out.\n    // WARNING: This means INSERT/UPDATE operations won't return the new data immediately.\n    mysqlQuery = mysqlQuery.replace(/RETURNING \\*|RETURNING \\w+/gi, '');\n\n    try {\n      // 4. Execute the raw query using Prisma\n      // Note: We use db.$queryRawUnsafe because we are manually building the query string\n      const result = await db.$queryRawUnsafe(mysqlQuery, ...params);\n      \n      // 5. Ensure we return an array (Prisma sometimes returns objects for metadata)\n      if (Array.isArray(result)) {\n        return result;\n      } \n      \n      // If it's an INSERT/UPDATE result in MySQL, it's not an array of rows.\n      // We return an empty array to prevent the app from crashing when it tries to read result[0].\n      return [];\n      \n    } catch (error) {\n      console.error(\"SQL Adapter Error:\", error);\n      throw error;\n    }\n  };\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM;AAEC,MAAM,KACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,gBAAgB,MAAM,GAAG;AAI7D,SAAS;IACd,OAAO,OAAO,OAAe,SAAgB,EAAE;QAC7C,+DAA+D;QAC/D,IAAI,aAAa,MAAM,OAAO,CAAC,UAAU;QAEzC,+FAA+F;QAC/F,aAAa,WAAW,OAAO,CAAC,WAAW;QAE3C,qCAAqC;QACrC,iEAAiE;QACjE,sFAAsF;QACtF,aAAa,WAAW,OAAO,CAAC,gCAAgC;QAEhE,IAAI;YACF,wCAAwC;YACxC,oFAAoF;YACpF,MAAM,SAAS,MAAM,GAAG,eAAe,CAAC,eAAe;YAEvD,+EAA+E;YAC/E,IAAI,MAAM,OAAO,CAAC,SAAS;gBACzB,OAAO;YACT;YAEA,uEAAuE;YACvE,6FAA6F;YAC7F,OAAO,EAAE;QAEX,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,sBAAsB;YACpC,MAAM;QACR;IACF;AACF"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///var/www/html/afyadiet/app/api/nutritionist/profile/route.ts"],"sourcesContent":["import { getSessionFromCookie } from \"@/lib/session\"\nimport { db } from \"@/lib/db\"\nimport { type NextRequest, NextResponse } from \"next/server\"\nimport fs from \"fs\"\nimport path from \"path\"\n\n// ðŸ’¡ HELPER: Convert Base64 String to a Physical File\nconst saveFile = (base64String: string, userId: number) => {\n  try {\n    // 1. If it's already a URL (not base64), just return it\n    if (!base64String || !base64String.startsWith(\"data:\")) return base64String; \n\n    // 2. Parse the Base64 data\n    const match = base64String.match(/^data:(.+);base64,(.+)$/);\n    if (!match) throw new Error(\"Invalid file data\");\n\n    const mimeType = match[1];\n    const base64Data = match[2];\n    \n    // Determine extension (pdf or image)\n    const ext = mimeType.includes(\"pdf\") ? \"pdf\" : \"png\";\n\n    // 3. Create a unique filename\n    const fileName = `kndi_${userId}_${Date.now()}.${ext}`;\n    const uploadDir = path.join(process.cwd(), \"public/uploads\");\n    \n    // 4. Ensure the 'public/uploads' folder exists\n    if (!fs.existsSync(uploadDir)) {\n      fs.mkdirSync(uploadDir, { recursive: true });\n    }\n\n    // 5. Write the file to disk\n    fs.writeFileSync(path.join(uploadDir, fileName), base64Data, \"base64\");\n\n    // 6. Return the clean URL for the database\n    return `/uploads/${fileName}`;\n  } catch (e) {\n    console.error(\"File save error:\", e);\n    return null;\n  }\n};\n\nexport async function GET() {\n  try {\n    const session = await getSessionFromCookie()\n    if (!session || session.role !== \"nutritionist\") {\n      return NextResponse.json({ error: \"Unauthorized access\" }, { status: 401 })\n    }\n\n    const userId = parseInt(session.userId, 10);\n    if (isNaN(userId)) {\n        return NextResponse.json({ error: \"Invalid User ID in session\" }, { status: 400 })\n    }\n\n    const profile = await db.nutritionist.findUnique({\n      where: { userId: userId },\n      include: {\n        user: { select: { name: true, email: true, avatar_url: true } }\n      }\n    })\n\n    if (!profile) {\n      return NextResponse.json({ profile: null })\n    }\n\n    return NextResponse.json({\n      profile: {\n        ...profile,\n        full_name: profile.user.name,\n        email: profile.user.email,\n        avatar_url: profile.user.avatar_url, \n        years_experience: profile.experience_years,\n        // Send expiry date to frontend\n        license_expires_at: profile.license_expires_at\n      }\n    })\n  } catch (error: any) {\n    console.error(\"[v0] Profile GET error:\", error)\n    return NextResponse.json({ error: \"Failed to load profile. \" + error.message }, { status: 500 })\n  }\n}\n\nexport async function PUT(request: NextRequest) {\n  try {\n    const session = await getSessionFromCookie()\n    if (!session || session.role !== \"nutritionist\") {\n      return NextResponse.json({ error: \"Unauthorized access\" }, { status: 401 })\n    }\n\n    const userId = parseInt(session.userId, 10);\n    if (isNaN(userId)) {\n        return NextResponse.json({ error: \"Invalid User ID\" }, { status: 400 })\n    }\n\n    const body = await request.json()\n    const { bio, specializations, certifications, yearsExperience, hourlyRate, avatarUrl, kndiDocumentUrl, licenseExpiresAt } = body\n\n    if (!bio || bio.length < 10) {\n      return NextResponse.json({ error: \"Bio is too short. Please write at least 10 characters.\" }, { status: 400 })\n    }\n    \n    // ðŸ’¡ HERE IS THE FIX: Convert the Base64 doc to a File URL\n    const cleanDocUrl = kndiDocumentUrl ? saveFile(kndiDocumentUrl, userId) : null;\n\n    const specialtyString = Array.isArray(specializations) \n      ? specializations.join(\", \") \n      : (specializations || \"\");\n\n    const result = await db.$transaction(async (tx) => {\n      \n      if (avatarUrl) {\n        await tx.user.update({\n          where: { id: userId },\n          data: { avatar_url: avatarUrl }\n        })\n      }\n\n      const updatedProfile = await tx.nutritionist.upsert({\n        where: { userId: userId },\n        update: {\n          bio,\n          specialty: specialtyString,\n          certifications,\n          experience_years: parseInt(yearsExperience || 0), \n          hourly_rate: parseFloat(hourlyRate || 0),\n          // Save the clean URL (e.g., /uploads/file.pdf), NOT the huge base64 string\n          kndi_document_url: cleanDocUrl,\n          license_expires_at: licenseExpiresAt ? new Date(licenseExpiresAt) : null,\n          verification_status: cleanDocUrl ? \"submitted\" : \"pending\"\n        },\n        create: {\n          userId: userId,\n          bio,\n          specialty: specialtyString || 'General',\n          certifications,\n          experience_years: parseInt(yearsExperience || 0), \n          hourly_rate: parseFloat(hourlyRate || 0),\n          is_verified: false,\n          // Save the clean URL here too\n          kndi_document_url: cleanDocUrl,\n          license_expires_at: licenseExpiresAt ? new Date(licenseExpiresAt) : null,\n          verification_status: cleanDocUrl ? \"submitted\" : \"pending\"\n        }\n      })\n\n      return updatedProfile\n    })\n\n    return NextResponse.json({ success: true, profile: result })\n\n  } catch (error: any) {\n    console.error(\"[v0] Profile PUT error:\", error)\n    return NextResponse.json({ error: \"Save failed: \" + error.message }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,sDAAsD;AACtD,MAAM,WAAW,CAAC,cAAsB;IACtC,IAAI;QACF,wDAAwD;QACxD,IAAI,CAAC,gBAAgB,CAAC,aAAa,UAAU,CAAC,UAAU,OAAO;QAE/D,2BAA2B;QAC3B,MAAM,QAAQ,aAAa,KAAK,CAAC;QACjC,IAAI,CAAC,OAAO,MAAM,IAAI,MAAM;QAE5B,MAAM,WAAW,KAAK,CAAC,EAAE;QACzB,MAAM,aAAa,KAAK,CAAC,EAAE;QAE3B,qCAAqC;QACrC,MAAM,MAAM,SAAS,QAAQ,CAAC,SAAS,QAAQ;QAE/C,8BAA8B;QAC9B,MAAM,WAAW,CAAC,KAAK,EAAE,OAAO,CAAC,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK;QACtD,MAAM,YAAY,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;QAE3C,+CAA+C;QAC/C,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,YAAY;YAC7B,wGAAE,CAAC,SAAS,CAAC,WAAW;gBAAE,WAAW;YAAK;QAC5C;QAEA,4BAA4B;QAC5B,wGAAE,CAAC,aAAa,CAAC,4GAAI,CAAC,IAAI,CAAC,WAAW,WAAW,YAAY;QAE7D,2CAA2C;QAC3C,OAAO,CAAC,SAAS,EAAE,UAAU;IAC/B,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO;IACT;AACF;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,UAAU,MAAM,IAAA,wIAAoB;QAC1C,IAAI,CAAC,WAAW,QAAQ,IAAI,KAAK,gBAAgB;YAC/C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,MAAM,SAAS,SAAS,QAAQ,MAAM,EAAE;QACxC,IAAI,MAAM,SAAS;YACf,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA6B,GAAG;gBAAE,QAAQ;YAAI;QACpF;QAEA,MAAM,UAAU,MAAM,iHAAE,CAAC,YAAY,CAAC,UAAU,CAAC;YAC/C,OAAO;gBAAE,QAAQ;YAAO;YACxB,SAAS;gBACP,MAAM;oBAAE,QAAQ;wBAAE,MAAM;wBAAM,OAAO;wBAAM,YAAY;oBAAK;gBAAE;YAChE;QACF;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAK;QAC3C;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;gBACP,GAAG,OAAO;gBACV,WAAW,QAAQ,IAAI,CAAC,IAAI;gBAC5B,OAAO,QAAQ,IAAI,CAAC,KAAK;gBACzB,YAAY,QAAQ,IAAI,CAAC,UAAU;gBACnC,kBAAkB,QAAQ,gBAAgB;gBAC1C,+BAA+B;gBAC/B,oBAAoB,QAAQ,kBAAkB;YAChD;QACF;IACF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,6BAA6B,MAAM,OAAO;QAAC,GAAG;YAAE,QAAQ;QAAI;IAChG;AACF;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,UAAU,MAAM,IAAA,wIAAoB;QAC1C,IAAI,CAAC,WAAW,QAAQ,IAAI,KAAK,gBAAgB;YAC/C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,MAAM,SAAS,SAAS,QAAQ,MAAM,EAAE;QACxC,IAAI,MAAM,SAAS;YACf,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAkB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,GAAG,EAAE,eAAe,EAAE,cAAc,EAAE,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,eAAe,EAAE,gBAAgB,EAAE,GAAG;QAE5H,IAAI,CAAC,OAAO,IAAI,MAAM,GAAG,IAAI;YAC3B,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAyD,GAAG;gBAAE,QAAQ;YAAI;QAC9G;QAEA,2DAA2D;QAC3D,MAAM,cAAc,kBAAkB,SAAS,iBAAiB,UAAU;QAE1E,MAAM,kBAAkB,MAAM,OAAO,CAAC,mBAClC,gBAAgB,IAAI,CAAC,QACpB,mBAAmB;QAExB,MAAM,SAAS,MAAM,iHAAE,CAAC,YAAY,CAAC,OAAO;YAE1C,IAAI,WAAW;gBACb,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;oBACnB,OAAO;wBAAE,IAAI;oBAAO;oBACpB,MAAM;wBAAE,YAAY;oBAAU;gBAChC;YACF;YAEA,MAAM,iBAAiB,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC;gBAClD,OAAO;oBAAE,QAAQ;gBAAO;gBACxB,QAAQ;oBACN;oBACA,WAAW;oBACX;oBACA,kBAAkB,SAAS,mBAAmB;oBAC9C,aAAa,WAAW,cAAc;oBACtC,2EAA2E;oBAC3E,mBAAmB;oBACnB,oBAAoB,mBAAmB,IAAI,KAAK,oBAAoB;oBACpE,qBAAqB,cAAc,cAAc;gBACnD;gBACA,QAAQ;oBACN,QAAQ;oBACR;oBACA,WAAW,mBAAmB;oBAC9B;oBACA,kBAAkB,SAAS,mBAAmB;oBAC9C,aAAa,WAAW,cAAc;oBACtC,aAAa;oBACb,8BAA8B;oBAC9B,mBAAmB;oBACnB,oBAAoB,mBAAmB,IAAI,KAAK,oBAAoB;oBACpE,qBAAqB,cAAc,cAAc;gBACnD;YACF;YAEA,OAAO;QACT;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAM,SAAS;QAAO;IAE5D,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,kBAAkB,MAAM,OAAO;QAAC,GAAG;YAAE,QAAQ;QAAI;IACrF;AACF"}}]
}